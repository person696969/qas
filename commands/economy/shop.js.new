const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, StringSelectMenuBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const config = require('../../config');

const shopItems = {
    tools: [
        { id: 'compass', name: 'Magic Compass', price: 500, description: 'Reduces hunt time by 20%', emoji: 'üß≠' },
        { id: 'shovel', name: 'Golden Shovel', price: 1000, description: 'Increases treasure rewards by 15%', emoji: '‚õèÔ∏è' },
        { id: 'map', name: 'Ancient Map', price: 2000, description: 'Reveals hint for free once per day', emoji: 'üó∫Ô∏è' },
        { id: 'key', name: 'Master Key', price: 3000, description: 'Skip any riddle without penalty', emoji: 'üóùÔ∏è' }
    ],
    weapons: [
        { id: 'sword', name: 'Iron Sword', price: 800, description: '+10 Attack Power', emoji: '‚öîÔ∏è' },
        { id: 'axe', name: 'Battle Axe', price: 1200, description: '+15 Attack Power', emoji: 'ü™ì' },
        { id: 'staff', name: 'Magic Staff', price: 1500, description: '+20 Magic Power', emoji: 'üîÆ' },
        { id: 'bow', name: 'Elven Bow', price: 1000, description: '+12 Ranged Power', emoji: 'üèπ' }
    ],
    armor: [
        { id: 'helmet', name: 'Steel Helmet', price: 600, description: '+8 Defense', emoji: '‚õëÔ∏è' },
        { id: 'chestplate', name: 'Iron Chestplate', price: 1500, description: '+20 Defense', emoji: 'üõ°Ô∏è' },
        { id: 'boots', name: 'Swift Boots', price: 400, description: '+5 Speed', emoji: 'üë¢' },
        { id: 'cape', name: 'Mystic Cape', price: 2500, description: '+25 Magic Defense', emoji: 'üß•' }
    ],
    potions: [
        { id: 'health', name: 'Health Potion', price: 50, description: 'Restores 50 HP', emoji: 'üß™' },
        { id: 'mana', name: 'Mana Potion', price: 75, description: 'Restores 30 MP', emoji: 'üíô' },
        { id: 'luck', name: 'Luck Potion', price: 200, description: 'Double rewards for 1 hour', emoji: 'üçÄ' },
        { id: 'strength', name: 'Strength Potion', price: 150, description: '+50% damage for 30 min', emoji: 'üí™' }
    ],
    pets: [
        { id: 'wolf', name: 'Loyal Wolf', price: 5000, description: 'Companion that finds extra coins', emoji: 'üê∫' },
        { id: 'dragon', name: 'Baby Dragon', price: 10000, description: 'Powerful companion for battles', emoji: 'üêâ' },
        { id: 'phoenix', name: 'Phoenix Chick', price: 15000, description: 'Revives you once per day', emoji: 'üî•' },
        { id: 'unicorn', name: 'Unicorn', price: 20000, description: 'Magical companion with healing', emoji: 'ü¶Ñ' }
    ]
};

const { updateUserData, getUserData } = require('../../database');

module.exports = {
    data: new SlashCommandBuilder()
        .setName('shop')
        .setDescription('üõí Browse and purchase items from the treasure shop!')
        .addSubcommand(subcommand =>
            subcommand
                .setName('browse')
                .setDescription('Browse items in the shop')
                .addStringOption(option =>
                    option.setName('category')
                        .setDescription('Browse specific item category')
                        .setRequired(false)
                        .addChoices(
                            { name: 'üîß Tools & Utilities', value: 'tools' },
                            { name: '‚öîÔ∏è Weapons', value: 'weapons' },
                            { name: 'üõ°Ô∏è Armor & Defense', value: 'armor' },
                            { name: 'üß™ Potions & Consumables', value: 'potions' },
                            { name: 'üêæ Pets & Companions', value: 'pets' }
                        )))
        .addSubcommand(subcommand =>
            subcommand
                .setName('buy')
                .setDescription('Purchase an item')
                .addStringOption(option =>
                    option.setName('item')
                        .setDescription('Item to purchase')
                        .setRequired(true)
                        .setAutocomplete(true))
                .addIntegerOption(option =>
                    option.setName('quantity')
                        .setDescription('Quantity to purchase')
                        .setRequired(false)
                        .setMinValue(1)
                        .setMaxValue(100)))
        .addSubcommand(subcommand =>
            subcommand
                .setName('sell')
                .setDescription('Sell an item from your inventory')
                .addStringOption(option =>
                    option.setName('item')
                        .setDescription('Item to sell')
                        .setRequired(true)
                        .setAutocomplete(true))
                .addIntegerOption(option =>
                    option.setName('quantity')
                        .setDescription('Quantity to sell')
                        .setRequired(false)
                        .setMinValue(1)
                        .setMaxValue(100))),

    async execute(interaction) {
        try {
            await interaction.deferReply();

            const userData = await getUserData(interaction.user.id);
            if (!userData) {
                await interaction.editReply('‚ùå Please create a profile first using `/profile create`!');
                return;
            }

            const subcommand = interaction.options.getSubcommand();
            switch (subcommand) {
                case 'browse': {
                    const category = interaction.options.getString('category');
                    if (category) {
                        await this.showCategory(interaction, category, userData);
                    } else {
                        await this.showMainShop(interaction, userData);
                    }
                    break;
                }
                case 'buy': {
                    const item = interaction.options.getString('item');
                    const quantity = interaction.options.getInteger('quantity') || 1;
                    await this.handlePurchase(interaction, item, quantity, userData);
                    break;
                }
                case 'sell': {
                    const item = interaction.options.getString('item');
                    const quantity = interaction.options.getInteger('quantity') || 1;
                    await this.handleSale(interaction, item, quantity, userData);
                    break;
                }
            }
        } catch (error) {
            console.error('Error in shop command:', error);
            const errorMessage = '‚ùå An error occurred while processing your request.';
            if (!interaction.replied && !interaction.deferred) {
                await interaction.reply({ content: errorMessage, ephemeral: true });
            } else {
                await interaction.editReply({ content: errorMessage, ephemeral: true });
            }
        }
    },

    async showMainShop(interaction, userData) {
        const embed = new EmbedBuilder()
            .setTitle('üè™ Welcome to the Shop!')
            .setDescription('Browse our categories and find what you need!')
            .setColor('#FFD700')
            .addFields(
                { name: 'üí∞ Your Balance', value: `${userData.coins} coins`, inline: true },
                { name: '\u200B', value: '\u200B', inline: true },
                { name: 'üì¶ Inventory Space', value: `${Object.keys(userData.inventory || {}).length}/100`, inline: true }
            );

        const row = new ActionRowBuilder()
            .addComponents(
                new StringSelectMenuBuilder()
                    .setCustomId('shop_category')
                    .setPlaceholder('Select a category to browse')
                    .addOptions([
                        { label: 'Tools & Utilities', value: 'tools', emoji: 'üîß', description: 'Essential tools for treasure hunting' },
                        { label: 'Weapons', value: 'weapons', emoji: '‚öîÔ∏è', description: 'Increase your combat effectiveness' },
                        { label: 'Armor & Defense', value: 'armor', emoji: 'üõ°Ô∏è', description: 'Protect yourself in battle' },
                        { label: 'Potions & Consumables', value: 'potions', emoji: 'üß™', description: 'Healing and temporary boosts' },
                        { label: 'Pets & Companions', value: 'pets', emoji: 'üêæ', description: 'Loyal friends for your journey' }
                    ])
            );

        const response = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        try {
            const filter = i => i.user.id === interaction.user.id && i.customId === 'shop_category';
            const collector = response.createMessageComponentCollector({ filter, time: 60000 });

            collector.on('collect', async i => {
                await i.deferUpdate();
                await this.showCategory(interaction, i.values[0], userData);
                collector.stop();
            });

            collector.on('end', async (collected, reason) => {
                if (reason === 'time') {
                    const disabledRow = new ActionRowBuilder()
                        .addComponents(
                            StringSelectMenuBuilder.from(row.components[0])
                                .setDisabled(true)
                                .setPlaceholder('Timed out - Run command again')
                        );

                    await interaction.editReply({
                        embeds: [embed],
                        components: [disabledRow]
                    });
                }
            });
        } catch (error) {
            console.error('Error in shop collector:', error);
        }
    },

    async showCategory(interaction, category, userData) {
        const items = shopItems[category] || [];
        if (items.length === 0) {
            await interaction.editReply('‚ùå No items found in this category!');
            return;
        }

        const embed = new EmbedBuilder()
            .setTitle(`${this.getCategoryEmoji(category)} ${this.getCategoryName(category)}`)
            .setDescription('Select an item to purchase:')
            .setColor('#FFD700')
            .setFields(items.map(item => ({
                name: `${item.emoji} ${item.name}`,
                value: `üí∞ **${item.price}** coins\n${item.description}`,
                inline: true
            })))
            .addFields({ name: 'üí∞ Your Balance', value: `${userData.coins} coins`, inline: false });

        const row = new ActionRowBuilder()
            .addComponents(
                new StringSelectMenuBuilder()
                    .setCustomId('shop_item')
                    .setPlaceholder('Select an item to purchase')
                    .addOptions(items.map(item => ({
                        label: `${item.name} (${item.price} coins)`,
                        value: item.id,
                        description: item.description.substring(0, 50),
                        emoji: item.emoji
                    })))
            );

        const backButton = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('shop_back')
                    .setLabel('Back to Categories')
                    .setStyle(ButtonStyle.Secondary)
            );

        const response = await interaction.editReply({
            embeds: [embed],
            components: [row, backButton]
        });

        try {
            const filter = i => i.user.id === interaction.user.id;
            const collector = response.createMessageComponentCollector({ filter, time: 60000 });

            collector.on('collect', async i => {
                await i.deferUpdate();

                if (i.customId === 'shop_back') {
                    await this.showMainShop(interaction, userData);
                    collector.stop();
                    return;
                }

                if (i.customId === 'shop_item') {
                    const selectedItem = items.find(item => item.id === i.values[0]);
                    if (selectedItem) {
                        await this.handlePurchase(interaction, selectedItem.id, 1, userData);
                        collector.stop();
                    }
                }
            });

            collector.on('end', async (collected, reason) => {
                if (reason === 'time') {
                    const disabledComponents = [row, backButton].map(component =>
                        ActionRowBuilder.from(component).setComponents(
                            component.components[0].setDisabled(true)
                        )
                    );

                    await interaction.editReply({
                        embeds: [embed],
                        components: disabledComponents
                    });
                }
            });
        } catch (error) {
            console.error('Error in category collector:', error);
        }
    },

    async handlePurchase(interaction, itemId, quantity, userData) {
        let foundItem = null;
        for (const categoryItems of Object.values(shopItems)) {
            foundItem = categoryItems.find(item => item.id === itemId);
            if (foundItem) break;
        }

        if (!foundItem) {
            await interaction.editReply('‚ùå Item not found!');
            return;
        }

        const totalCost = foundItem.price * quantity;
        if (userData.coins < totalCost) {
            await interaction.editReply(`‚ùå You don't have enough coins! You need ${totalCost} coins.`);
            return;
        }

        // Update user data
        userData.coins -= totalCost;
        userData.inventory = userData.inventory || {};
        userData.inventory[itemId] = (userData.inventory[itemId] || 0) + quantity;

        try {
            await updateUserData(interaction.user.id, userData);

            const embed = new EmbedBuilder()
                .setTitle('Purchase Successful!')
                .setDescription(`You bought ${quantity}x ${foundItem.emoji} ${foundItem.name}`)
                .setColor('#00FF00')
                .addFields(
                    { name: 'üí∞ Total Cost', value: `${totalCost} coins`, inline: true },
                    { name: 'üí∞ Remaining Balance', value: `${userData.coins} coins`, inline: true }
                );

            await interaction.editReply({ embeds: [embed] });
        } catch (error) {
            console.error('Error updating user data:', error);
            await interaction.editReply('‚ùå Failed to complete the purchase. Please try again.');
        }
    },

    async handleSale(interaction, itemId, quantity, userData) {
        let foundItem = null;
        for (const categoryItems of Object.values(shopItems)) {
            foundItem = categoryItems.find(item => item.id === itemId);
            if (foundItem) break;
        }

        if (!foundItem) {
            await interaction.editReply('‚ùå Item not found!');
            return;
        }

        const currentQuantity = userData.inventory?.[itemId] || 0;
        if (currentQuantity < quantity) {
            await interaction.editReply(`‚ùå You don't have enough ${foundItem.name} to sell!`);
            return;
        }

        const sellPrice = Math.floor(foundItem.price * 0.5); // 50% of original price
        const totalEarnings = sellPrice * quantity;

        // Update user data
        userData.coins += totalEarnings;
        userData.inventory[itemId] -= quantity;
        if (userData.inventory[itemId] <= 0) {
            delete userData.inventory[itemId];
        }

        try {
            await updateUserData(interaction.user.id, userData);

            const embed = new EmbedBuilder()
                .setTitle('Sale Successful!')
                .setDescription(`You sold ${quantity}x ${foundItem.emoji} ${foundItem.name}`)
                .setColor('#00FF00')
                .addFields(
                    { name: 'üí∞ Earnings', value: `${totalEarnings} coins`, inline: true },
                    { name: 'üí∞ New Balance', value: `${userData.coins} coins`, inline: true }
                );

            await interaction.editReply({ embeds: [embed] });
        } catch (error) {
            console.error('Error updating user data:', error);
            await interaction.editReply('‚ùå Failed to complete the sale. Please try again.');
        }
    },

    getCategoryName(category) {
        const names = {
            tools: 'Tools & Utilities',
            weapons: 'Weapons',
            armor: 'Armor & Defense',
            potions: 'Potions & Consumables',
            pets: 'Pets & Companions'
        };
        return names[category] || 'Unknown Category';
    },

    getCategoryEmoji(category) {
        const emojis = {
            tools: 'üîß',
            weapons: '‚öîÔ∏è',
            armor: 'üõ°Ô∏è',
            potions: 'üß™',
            pets: 'üêæ'
        };
        return emojis[category] || '‚ùì';
    }
};
